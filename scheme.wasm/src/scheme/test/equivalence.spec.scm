(if (not (procedure? assert))
  (include "test/test.scm"))

(run-tests "equivalence"
  (test-case "(eqv? <obj_1> <obj_2>)" (lambda ()
    (assert (eqv? 'a 'a))
    (assert-not (eqv? 'a 'b))
    (assert (eqv? 2 2))
    (assert-not (eqv? 2 2.0))
    (assert (eqv? '() '()))
    (assert (eqv? #t #t))
    (assert-not (eqv? #t #f))
    (assert (eqv? #f #f))
    (assert-not (eqv? #\A #\a))
    (assert (eqv? #\a #\a))
    (assert (eqv? #\Î´ #\x3b4))
    (assert (eqv? 100000000 100000000))
    (assert-not (eqv? 0.0 +nan.0))
    (assert-not (eqv? (cons 1 2) (cons 1 2)))
    (assert-not (eqv? (lambda () 1) (lambda () 2)))
    (let ((p (lambda (x) x)))
      (assert (eqv? p p) " p <== (lambda (x) x)"))
    (assert-not (eqv? #f 'nil))
    
    (define gen-counter
      (lambda ()
        (let ((n 0))
          (lambda () (set! n (+ 1 n)) n))))
    (let ((g (gen-counter)))
      (assert (eqv? g g) "same instances of the lambda should be the same"))
    (assert-not (eqv? (gen-counter) (gen-counter)) "difference instnace should be different")

    (letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
             (g (lambda () (if (eqv? f g) 'both 'g))))
      (assert-not (eqv? f g)))

    (let ((x '(a)))
      (assert (eqv? x x)))))

  (test-case "(eq? <obj_1> <obj_2>)" (lambda ()
    (assert (eq? 'a 'a))
    (assert-not (eq? 'a 'b))
    (assert (eq? #t #t))
    (assert-not (eq? #t #f))
    (assert (eq? #f #f))
    (assert (eq? () ()))
    (assert-not (eq? (cons 1 2) (cons 1 2)))
    (let ((p (lambda (x) x)))
      (assert (eq? p p) " p <== (lambda (x) x)"))
    
    (let ((x '(a)))
      (assert (eq? x x)))))

  (test-case "(equal? <obj_1> <obj_2>)" (lambda ()
    (assert (equal? 'a 'a))
    (assert (equal? '(a) '(a)))
    (assert (equal? '(a (b) c) '(a (b) c)))
    (assert (equal? "abc" "abc"))
    (assert (equal? 2 2))
    (assert (equal? (make-vector 5 'a) (make-vector 5 'a)))
    ; TODO implement labels
    ; (assert (equal? '#1=(a b . #1#) '#2=(a b a b . #2#)))
    (assert (equal? (lambda (x) x) (lambda (x) x)))

  ))
)
